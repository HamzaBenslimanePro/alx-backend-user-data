This Python code snippet is designed to filter sensitive information (like PII—Personally Identifiable Information) from a log message. It uses regular expressions (regex) to identify and replace specific fields with a redacted string. Let’s break down the code step by step with detailed explanations and an example.

### 1. **Understanding the `patterns` dictionary**

The `patterns` dictionary contains two lambda functions:
- **`extract`**: This function creates a regex pattern to find fields in the message.
- **`replace`**: This function creates a replacement pattern for the fields found.

#### `patterns['extract']`:
```python
'extract': lambda x, y: r'(?P<field>{})=[^{}]*'.format('|'.join(x), y),
```
- **`x`**: This is a list of field names (e.g., `["name", "email", "phone"]`).
- **`y`**: This is the separator, which typically separates key-value pairs in the log message (e.g., a space, comma, or semicolon).

The lambda function constructs a regex pattern using these inputs:
- `r'(?P<field>{})=[^{}]*'`:
  - `(?P<field>{})`: This is a named capturing group called `field`. It captures one of the field names provided in the list `x`, joined by a `|` (OR) operator. So, for `x = ["name", "email"]`, this would match either "name" or "email".
  - `=[^{}]*`: This matches the `=` sign followed by any characters that are not the separator `y`, effectively capturing the value of the field.

#### `patterns['replace']`:
```python
'replace': lambda x: r'\g<field>={}'.format(x),
```
- **`x`**: This is the redaction string (e.g., `"[REDACTED]"`).

The lambda function constructs a replacement pattern using this input:
- `r'\g<field>={}'`:
  - `\g<field>`: This refers to the captured field name from the regex.
  - `={}`: This is the redaction string that will replace the original value.

### 2. **`filter_datum` function**

This function uses the patterns to redact sensitive information in a given message.

#### Parameters:
- **`fields`**: A list of field names to be redacted (e.g., `["name", "email"]`).
- **`redaction`**: The string that will replace the sensitive data (e.g., `"[REDACTED]"`).
- **`message`**: The log message containing the fields and their values.
- **`separator`**: The character that separates key-value pairs in the message (e.g., `';'`).

#### How it works:
1. **Extract and Replace**:
   - The `extract` lambda creates a regex pattern to find the fields in the message.
   - The `replace` lambda creates the replacement pattern with the redaction string.
  
2. **Substitute**:
   - `re.sub` is used to search the `message` for the pattern generated by `extract(fields, separator)` and replace it with the pattern generated by `replace(redaction)`.

#### Example:

Suppose you have the following log message:

```python
message = "name=John Doe; email=johndoe@example.com; phone=123-456-7890; ssn=123-45-6789; password=secret;"
fields = ["name", "email", "ssn"]
redaction = "[REDACTED]"
separator = ";"
```

Calling `filter_datum(fields, redaction, message, separator)` would process the message like this:

1. **`extract(fields, separator)`** generates the regex pattern:
   ```python
   r'(?P<field>name|email|ssn)=[^;]*'
   ```
   This pattern matches any of the fields `"name"`, `"email"`, or `"ssn"` followed by `=` and any characters until it encounters the separator `";"`.

2. **`replace(redaction)`** generates the replacement pattern:
   ```python
   r'\g<field>=[REDACTED]'
   ```
   This pattern replaces the matched fields' values with `[REDACTED]`.

3. **`re.sub`** applies the regex pattern to the `message`, replacing the matched parts with the redaction string.

**Output:**
```python
"name=[REDACTED]; email=[REDACTED]; phone=123-456-7890; ssn=[REDACTED]; password=secret;"
```

This effectively redacts the specified fields while leaving the rest of the message intact.